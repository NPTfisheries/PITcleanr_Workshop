---
title: "PITcleanr Workshop"
author:
  - Ryan N. Kinzer
  - Mike Ackerman
  - Kevin See
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{PITcleanr Workshop}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE, message = FALSE, warning = FALSE, results = "hide"}
# knitr options
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  echo = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)

library(knitr)
library(here)
library(kableExtra)

api_key = '1AA5CF55-C98E-4001-96E4-1E96CEE1E806'

```


# Installation

If necessary, the `PITcleanr` package can be installed as an R package from GitHub by using Hadley Wickham's `devtools` package. Additional information on package installation can be found on the [website README](https://github.com/KevinSee/PITcleanr?tab=readme-ov-file#installation-instructions). 

```{r gh-installation, eval = FALSE}
# install PITcleanr, if necessary
install.packages("devtools")
library(devtools)
remotes::install_github("KevinSee/PITcleanr", 
                         build_vignettes = TRUE)

```


# Load Packages

Once `PITcleanr` is successfully installed, it can be loaded into the R session. In this workshop, we will also use functions from the following packages. Packages can be loaded using the `library()` function. For any packages not already installed, the `install.packages()` function can be used first.

```{r load-packages}
# E.g., for packages not installed:
# install.packages(c("tidyverse", "sf"))

# load necessary packages
library(PITcleanr)
library(tidyverse)
library(sf)

```

# Query Data

## PTAGIS Site Information

### Interrogation Sites

`PITcleanr` can be used to query and download metadata for PTAGIS interrogation sites using the function `queryInterrogationMeta()`. The `site_code` argument can be used to specify sites; alternatively, set `site_code` to `NULL` to retrieve metadata for all sites.

```{r int-meta}
# interrogation site metadata
int_meta_KRS = queryInterrogationMeta(site_code = "KRS")
int_meta = queryInterrogationMeta(site_code = NULL)

# count active instream remote sites by organization
int_meta %>%
  filter(siteType == "Instream Remote Detection System",
         active) %>%
  count(operationsOrganizationCode) %>%
  ggplot(aes(x = operationsOrganizationCode, y = n)) +
    geom_col() + 
    coord_flip()

```

As an example, we can use the `int_meta` objects to map our interrogation sites using the `sf` package. State polygons are available in the `maps` package.

```{r int-map}
# plot location of interrogation sites
library(maps)

# get state boundaries
pnw = st_as_sf(map("state", 
                   region = c('ID', 'WA', 'OR'), 
                   plot = FALSE, 
                   fill = TRUE)) # get state boundaries

# create spatial feature object of IPTDS
int_sf <- int_meta %>% 
  filter(siteType == "Instream Remote Detection System",
         !is.na(longitude),
         !is.na(latitude)) %>%
  st_as_sf(coords = c('longitude', 'latitude'), 
           crs = 4326) # WGS84

ggplot() + 
  geom_sf(data = pnw) + 
  geom_sf(data = int_sf, aes(color = active))

```

`PITcleanr` also includes the function `queryInterrogationConfig()` function to query and download configuration metadata for PTAGIS interrogation sites. The configuration metadata contains information about individual antennas, transceivers, etc., including their arrangement. Similar to above, `site_code` can be set to `NULL` to get configuration metadata for all PTAGIS interrogation sites.

```{r int-config}
# configuration of an interrogation site
int_config <- queryInterrogationConfig(site_code = 'ZEN')

int_config %>%
  kable() %>%
  kable_styling(full_width = TRUE,
                bootstrap_options = 'striped')

```

### Mark/Recapture/Recovery Sites

A similar function exists to query and download metadata for PTAGIS mark-recapture-recovery (MRR) sites.

```{r mrr-meta}
# all MRR sites
mrr_meta <- queryMRRMeta(site = NULL)

```

### All PTAGIS Sites

`PITcleanr` includes additional functions that can query interrogation and MRR sites together. The `queryPtagisMeta()` function is a wrapper function to download all INT and MRR sites at once. The `buildConfig()` function goes a step further and downloads all INT and MRR site metadata, plus INT site configuration information, and applies some formatting to combine all PTAGIS site metadata.

```{r all-ptagis-sites}
# wrapper to download all site meta
ptagis_meta <- queryPtagisMeta()

# wrapper to download site metadata and INT configuration data at once, and apply some formatting
config <- buildConfig()

```

## PTAGIS Tag Data
```{r test-tag, eval = FALSE, echo = FALSE}
# not working, requires janitor, throws other errors
# Check for timer tags and site operation
#test_tags <- tmp_queryTestTagSite(site_code = "ZEN", year = 2023, api_key) # need API key
test_tags <- queryTestTagSite(site_code = "ZEN", year = 2023, api_key) # need API key

test_tags %>%
  group_by(antenna_id, time_stamp, tag_code) %>%
  count() %>%
  ggplot(aes(x = time_stamp, y = n, colour = tag_code)) +
  geom_point() +
  facet_wrap(~antenna_id)

```

```{r tag-meta}
# not working
#queryTagMeta("3D9.1C2D929849") # not exported
```

```{r complete-tag-history-site}
# download a PTAGIS complete tag history for a single tag code
tagID <- "3D6.1D594D4AFA" # IR3, GOJ, BO1 -> IR5
tagID <- "3DD.003D494091" # GRA, IR1 -> IML

cth_site <- queryCapHist(ptagis_tag_code = tagID)

cth_site %>%
  group_by(event_type_name, event_site_code_value) %>%
  summarise(n_dets = n(),
            min_det = min(event_date_time_value),
            max_det = max(event_date_time_value)) %>%
  mutate(duration = difftime(max_det, min_det, units = "hours")) %>%
  kable() %>%
  kable_styling(full_width = TRUE,
            bootstrap_options = 'striped') 
```

```{r complete-tag-history-node, eval = FALSE, echo = FALSE}
# doesn't work - nothing is different from when config is not supplied
cth_node <- queryCapHist(ptagis_tag_code = tagID,
                         config = config,
                         include_mark = TRUE,
                         api_key = api_key)

glimpse(cth_node) %>%
  kable()
```


```{r MRR-single-file}
# MRR tag file summaries
mrr_file <- "NBD15065.TUM"
mrr_file <- "JSW-2022-175-001.xml"

mrr_data <- queryMRRDataFile(mrr_file)

mrr_data %>%
  filter(event_type == 'Mark') %>%
  group_by(event_date, species_run_rear_type) %>%
  count() %>%
  ggplot(aes(x = event_date, y = n, fill = species_run_rear_type)) +
  geom_col() +
  labs(title = paste0(unique(mrr_data$release_site), ' : ', mrr_file))

```
```{r MRR-LGRLDR}
# LGRLDR tag file summaries
mrr_file <- "JSW-2022-175-001.xml"

mrr_data <- queryMRRDataFile(mrr_file)

mrr_data %>%
  group_by(species_run_rear_type, text_comments) %>%
  count() %>%
  ggplot(aes(x = text_comments, y = n, fill = species_run_rear_type)) +
  geom_col() +
  coord_flip() +
  labs(title = paste0(unique(mrr_data$release_site), ' : ', mrr_file))

```


```{r MRR-multiple-files}
# iterate across multiple MRR tag files
julian <- str_pad(1:10,3,pad = 0) # julian date
yr <- 2024 # sampling year
mrr_files <- paste0('IMN-', yr, '-', julian,'-NT1.xml')

mrr_data <- map_df(mrr_files,  # loop across files
             .f = queryMRRDataFile)

mrr_data %>%
  filter(event_type == 'Mark') %>%
  mutate(release_date = date(release_date)) %>%
  group_by(release_date, species_run_rear_type) %>%
  count() %>%
  kable() %>%
  kable_styling(full_width = TRUE)
```



# Load PTAGIS Data

```{r build-filepath}
# the following code generates a file path to example PTAGIS complete tag history data
ptagis_file <- system.file("extdata", 
                          "TUM_chnk_cth_2018.csv",
                          package = "PITcleanr",
                          mustWork = TRUE)

# alternatively, you could use your own PTAGIS complete tag history file with the following fields:

# Tag, Mark Species, Mark Rear Type, Event Type, Event Site Type, Event Site Code, Event Date Time, Antenna, Antenna Group Configuration, Event Release Site Code, and Event Release Date Time.

#ptagis_file = "C:/Users/USER_NAME_HERE/Downloads/TUM_chnk_cth_2018.csv"
```


```{r raw-ptagis-data}
# load the complete tag history data and format the data based on the file_type
raw_ptagis <- readCTH(ptagis_file, file_type = "PTAGIS") %>%
    filter(event_date_time_value >= lubridate::ymd(20180301))

# alternatively you could read in the raw file without changes
#raw_ptagis <- readr::read_csv(ptagis_file)) 
```

```{r qc-data}
qc_detections = qcTagHistory(ptagis_file)
qc_detections
```


```{r tag-counts}
dplyr::n_distinct(raw_ptagis$tag_code)
# 
# mark_only_tags = raw_ptagis %>%
#   dplyr::select(`Tag Code`, `Event Type Name`) %>%
#   dplyr::count(`Tag Code`, `Event Type Name`) %>%
#   tidyr::pivot_wider(names_from = `Event Type Name`,
#                      values_from = n,
#                      values_fill = 0) %>%
#   #mutate(nDetections = rowSums(across(where(is.numeric)))) %>%
#   dplyr::filter(Observation == 0 & Recapture == 0 & Recovery == 0)
```

```{r config}
# the pre-built configuration file
configuration <- system.file("extdata", 
                             "TUM_configuration.csv", 
                             package = "PITcleanr",
                             mustWork = TRUE) |> 
  read_csv(show_col_types = F)

# the pre-built parent-child table
parent_child <- system.file("extdata", 
                            "TUM_parent_child.csv", 
                            package = "PITcleanr",
                            mustWork = TRUE) |> 
  read_csv(show_col_types = F)


```


```{r plot-parent-child}
# plot parent child configuration
plotNodes(parent_child)
```


```{r build-nodes}
parent_child_nodes <- addParentChildNodes(parent_child, config)
plotNodes(parent_child_nodes)
```

```{r build-node-order}
node_order <- buildNodeOrder(parent_child_nodes)
```


```{r compress-data}
comp_obs <- compress(raw_ptagis,
                 configuration = config)

#dim(raw_ptagis) # 13294
#dim(comp_obs) # 6755

head(comp_obs)
```


```{r add-direction}
comp_dir <- addDirection(comp_obs, parent_child_nodes, direction = "u")
```



```{r filter-detections}
comp_filter <- filterDetections(comp_obs, parent_child)
```

```{r auto-keep}
# after double checking PITcleanr calls filter out the final dataset for further analysis 
comp_final <- comp_filter %>%
  filter(auto_keep_obs)
```

```{r summarise-dets}
node_tags <- comp_final %>%
  group_by(node) %>%
  summarise(n_tags = n_distinct(tag_code))
```

```{r est-eff}
node_eff <- estNodeEff(comp_final, node_order = node_order)
```

```{r plot-est-tags}
# plot tags on a map
```